use crate::ast_utils::{Grammar, Rule, NamedExpr, Expr};
use crate::tok::{Token, ScanError};
use std::str::FromStr;
use std::iter::once;

grammar<'input>(text: &'input str);

pub Grammar: Grammar = {
    Token* <Rule+> => { Grammar { tokens: Vec::new(), rules: <> } },
};

pub Token: () = {
    <t:"TOKEN"> "=" <v:"LITERAL"> ";" => {}
};

pub Rule: Rule = {
    <n:"IDENT"> "=" <e:Expr> ";" => { Rule { name: n.to_string(), expr: e } },
};

pub Expr: Expr = {
    <e:Production> <es:("|" <Production>)*> => { if es.is_empty() { e } else { Expr::Alt(once(e).chain(es).collect()) } },
};

pub Production: Expr = {
    <nes:ProductionTerm+> <code:"CODE"> => { Expr::Seq(nes, code.to_string()) },
    Term,
};

pub ProductionTerm: NamedExpr = {
    <n:"IDENT"> ":" <e:Term> => { e.tag(Some(n.to_string())) },
    <Term> => { <>.tag(None) }
};

pub Term: Expr = {
    <e:Factor> "?" => { e.opt() },
    <e:Factor> "*" => { e.star() },
    <e:Factor> "+" => { e.plus() },
    Factor,
};

pub Factor: Expr = {
    "(" <Expr> ")",
    <"IDENT"> => { Expr::Rule(<>.to_string()) },
    <"TOKEN"> => { Expr::Token(<>.to_string()) },
    <"LITERAL"> => { Expr::Literal(<>.to_string()) },
};

extern {
    type Location = usize;
    type Error = ScanError;
    enum Token<'input> {
        "=" => Token::Equals,
        "|" => Token::Bar,
        "?" => Token::Opt,
        "*" => Token::Star,
        "+" => Token::Plus,
        "(" => Token::LParen,
        ")" => Token::RParen,
        ":" => Token::Colon,
        ";" => Token::Semi,
        "<" => Token::Less,
        ">" => Token::Greater,
        "IDENT" => Token::Ident(<&'input str>),
        "TOKEN" => Token::Token(<&'input str>),
        "CODE" => Token::Code(<&'input str>),
        "LITERAL" => Token::Literal(<&'input str>),
    }
}