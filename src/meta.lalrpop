use crate::{ast, tok};
use std::str::FromStr;
use std::iter::once;

grammar<'input>(text: &'input str);

pub Grammar: ast::Grammar = {
    <tokens:Token*> <rules:Rule+> => ast::Grammar { tokens, rules },
};

Token: ast::Token = {
    <t:"TOKEN"> "=" <regex:LiteralOrRegex> ";" => {
        ast::Token {
            name: t.to_string(),
            regex,
        }
    },
};

LiteralOrRegex: regex_deriv::RegEx = {
    <"LITERAL"> => ast::regex_literal(<>),
    <"REGEX"> => regex_deriv_syntax::parse(<>).unwrap(),
};

Rule: ast::Rule = {
    <n:"IDENT"> "=" <e:Expr> ";" => ast::Rule { name: n.to_string(), expr: e },
};

Expr: ast::Expr = {
    <e:Production> <es:("|" <Production>)*> => {
        if es.is_empty() { e } else { ast::Expr::Alt(once(e).chain(es).collect()) }
    },
};

Production: ast::Expr = {
    <nes:ProductionTerm+> <code:"CODE"> => ast::Expr::Seq(nes, code.to_string()),
    Term,
};

ProductionTerm: ast::NamedExpr = {
    <n:"IDENT"> ":" <e:Term> => e.tag(Some(n.to_string())),
    <Term> => <>.tag(None),
};

Term: ast::Expr = {
    <e:Factor> "?" => ast::Expr::Opt(Box::new(e)),
    <e:Factor> "*" => ast::Expr::Star(Box::new(e)),
    <e:Factor> "+" => ast::Expr::Plus(Box::new(e)),
    Factor,
};

Factor: ast::Expr = {
    "(" <Expr> ")",
    <"IDENT"> => ast::Expr::Rule(<>.to_string()),
    <"TOKEN"> => ast::Expr::Token(<>.to_string()),
    <"LITERAL"> => ast::Expr::Literal(<>.to_string()),
};

extern {
    type Location = usize;
    type Error = tok::ScanError;
    enum tok::Token<'input> {
        "="       => tok::Token::Equals,
        "|"       => tok::Token::Bar,
        "?"       => tok::Token::Opt,
        "*"       => tok::Token::Star,
        "+"       => tok::Token::Plus,
        "("       => tok::Token::LParen,
        ")"       => tok::Token::RParen,
        ":"       => tok::Token::Colon,
        ";"       => tok::Token::Semi,
        "<"       => tok::Token::Less,
        ">"       => tok::Token::Greater,
        "IDENT"   => tok::Token::Ident(<&'input str>),
        "TOKEN"   => tok::Token::Token(<&'input str>),
        "LITERAL" => tok::Token::Literal(<&'input str>),
        "REGEX"   => tok::Token::RegEx(<&'input str>),
        "CODE"    => tok::Token::Code(<&'input str>),
    }
}