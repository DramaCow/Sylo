// type ExprProduct = i32;

// // Expr -> Expr or Expr
// fn production_0() -> ExprProduct {
//     todo!()
// }

// // Expr -> Expr and Expr
// fn production_1() -> ExprProduct {
//     todo!()
// }

// // Expr -> Expr diff Expr
// fn production_2() -> ExprProduct {
//     todo!()
// }

// // Expr -> Expr Expr
// fn production_3() -> ExprProduct {
//     todo!()
// }

// // Expr -> Expr opt
// fn production_4() -> ExprProduct {
//     todo!()
// }

// // Expr -> Expr star
// fn production_5() -> ExprProduct {
//     todo!()
// }

// // Expr -> Expr plus
// fn production_6() -> ExprProduct {
//     todo!()
// }

// // Expr -> not Expr
// fn production_7() -> ExprProduct {
//     todo!()
// }

// // Expr -> lparen Expr rparen
// fn production_8() -> ExprProduct {
//     todo!()
// }

// // Expr -> string
// fn production_9() -> ExprProduct {
//     todo!()
// }

// // Expr -> CHAR
// fn production_10() -> ExprProduct {
//     todo!()
// }

// // Expr -> CHAR range CHAR
// fn production_11() -> ExprProduct {
//     todo!()
// }

// /* automatically generated by sylo */

// pub fn scan<I: AsRef<[u8]> + ?Sized>(input: &I) -> Scan<'_> {
//     Scan {
//         input: input.as_ref(),
//         index: 0,
//     }
// }

// pub struct Scan<'a> {
//     input: &'a [u8],
//     index: usize,
// }

// #[derive(Debug)]
// pub struct ScanError {
//     pub pos: usize,
// }

// #[derive(Debug, Clone, Copy)]
// pub enum TokenType {
//     string,
//     CHAR,
//     range,
//     and,
//     or,
//     diff,
//     opt,
//     star,
//     plus,
//     not,
//     lparen,
//     rparen,
// }

// #[derive(Debug, Clone, Copy)]
// pub struct Token {
//     pub ttype: TokenType,
//     pub span: (usize, usize),
// }

// pub struct TokenView<'a, T> {
//     token: Token,
//     input: &'a T
// }

// impl<'a> Iterator for Scan<'a> {
//     type Item = Result<Token, ScanError>;

//     fn next(&mut self) -> Option<Self::Item> {
//         self.begin()
//     }
// }

// enum LastAcceptTType {
//     Tok(TokenType),
//     Error,
//     Skip,
// }

// struct Context {
//     start_index: usize,
//     last_accept_ttype: LastAcceptTType,
//     last_accept_index: usize,
// }

// impl Scan<'_> {
//     fn begin(&mut self) -> Option<<Self as Iterator>::Item> {
//         if self.index >= self.input.len() {
//             return None;
//         }

//         let ctx = Context {
//             start_index: self.index,
//             last_accept_ttype: LastAcceptTType::Error,
//             last_accept_index: 0,
//         };

//         self.s0(ctx)
//     }

// // *** LEXER TABLE START ***

//     fn s0(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         if self.index >= self.input.len() { return self.sink(ctx); }
//         let ch = self.input[self.index];
//         ctx.last_accept_ttype = LastAcceptTType::Skip;
//         ctx.last_accept_index = self.index;
//         if ch == 0x22 { self.index += 1; return self.s1(ctx); }
//         if ch == 0x26 { self.index += 1; return self.s5(ctx); }
//         if ch == 0x27 { self.index += 1; return self.s6(ctx); }
//         if ch == 0x09 ||
//            ch == 0x0a ||
//            ch == 0x0d ||
//            ch == 0x20 { self.index += 1; return self.s10(ctx); }
//         if ch == 0x7c { self.index += 1; return self.s11(ctx); }
//         if ch == 0x3f { self.index += 1; return self.s12(ctx); }
//         if ch == 0x21 { self.index += 1; return self.s13(ctx); }
//         if ch == 0x29 { self.index += 1; return self.s14(ctx); }
//         if ch == 0x2e { self.index += 1; return self.s15(ctx); }
//         if ch == 0x28 { self.index += 1; return self.s17(ctx); }
//         if ch == 0x2b { self.index += 1; return self.s18(ctx); }
//         if ch == 0x2d { self.index += 1; return self.s19(ctx); }
//         if ch == 0x2a { self.index += 1; return self.s20(ctx); }
//         self.begin()
//     }

//     fn s1(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         if self.index >= self.input.len() { return self.sink(ctx); }
//         let ch = self.input[self.index];
//         if ch == 0x09 ||
//            ch == 0x0a ||
//            ch == 0x0d ||
//            ch == 0x20 ||
//            ch == 0x21 ||
//            (0x23 <= ch && ch <= 0x5b) ||
//            (0x5d <= ch && ch <= 0x7e) ||
//            (0xa0 <= ch && ch <= 0xff) { self.index += 1; return self.s2(ctx); }
//         if ch == 0x5c { self.index += 1; return self.s4(ctx); }
//         self.sink(ctx)
//     }

//     fn s2(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         if self.index >= self.input.len() { return self.sink(ctx); }
//         let ch = self.input[self.index];
//         if ch == 0x09 ||
//            ch == 0x0a ||
//            ch == 0x0d ||
//            ch == 0x20 ||
//            ch == 0x21 ||
//            (0x23 <= ch && ch <= 0x5b) ||
//            (0x5d <= ch && ch <= 0x7e) ||
//            (0xa0 <= ch && ch <= 0xff) { self.index += 1; return self.s2(ctx); }
//         if ch == 0x22 { self.index += 1; return self.s3(ctx); }
//         if ch == 0x5c { self.index += 1; return self.s4(ctx); }
//         self.sink(ctx)
//     }

//     fn s3(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::string, span: (ctx.start_index, self.index) }))
//     }

//     fn s4(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         if self.index >= self.input.len() { return self.sink(ctx); }
//         let ch = self.input[self.index];
//         if ch == 0x22 ||
//            ch == 0x5c { self.index += 1; return self.s2(ctx); }
//         self.sink(ctx)
//     }

//     fn s5(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::and, span: (ctx.start_index, self.index) }))
//     }

//     fn s6(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         if self.index >= self.input.len() { return self.sink(ctx); }
//         let ch = self.input[self.index];
//         if ch == 0x09 ||
//            ch == 0x0a ||
//            ch == 0x0d ||
//            ch == 0x20 ||
//            ch == 0x21 ||
//            (0x23 <= ch && ch <= 0x5b) ||
//            (0x5d <= ch && ch <= 0x7e) ||
//            (0xa0 <= ch && ch <= 0xff) { self.index += 1; return self.s7(ctx); }
//         if ch == 0x5c { self.index += 1; return self.s9(ctx); }
//         self.sink(ctx)
//     }

//     fn s7(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         if self.index >= self.input.len() { return self.sink(ctx); }
//         let ch = self.input[self.index];
//         if ch == 0x27 { self.index += 1; return self.s8(ctx); }
//         self.sink(ctx)
//     }

//     fn s8(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::CHAR, span: (ctx.start_index, self.index) }))
//     }

//     fn s9(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         if self.index >= self.input.len() { return self.sink(ctx); }
//         let ch = self.input[self.index];
//         if ch == 0x22 ||
//            ch == 0x5c { self.index += 1; return self.s7(ctx); }
//         self.sink(ctx)
//     }

//     fn s10(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         if self.index >= self.input.len() { return self.sink(ctx); }
//         let ch = self.input[self.index];
//         if ch == 0x09 ||
//            ch == 0x0a ||
//            ch == 0x0d ||
//            ch == 0x20 { self.index += 1; return self.s10(ctx); }
//         self.begin()
//     }

//     fn s11(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::or, span: (ctx.start_index, self.index) }))
//     }

//     fn s12(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::opt, span: (ctx.start_index, self.index) }))
//     }

//     fn s13(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::not, span: (ctx.start_index, self.index) }))
//     }

//     fn s14(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::rparen, span: (ctx.start_index, self.index) }))
//     }

//     fn s15(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         if self.index >= self.input.len() { return self.sink(ctx); }
//         let ch = self.input[self.index];
//         if ch == 0x2e { self.index += 1; return self.s16(ctx); }
//         self.sink(ctx)
//     }

//     fn s16(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::range, span: (ctx.start_index, self.index) }))
//     }

//     fn s17(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::lparen, span: (ctx.start_index, self.index) }))
//     }

//     fn s18(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::plus, span: (ctx.start_index, self.index) }))
//     }

//     fn s19(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::diff, span: (ctx.start_index, self.index) }))
//     }

//     fn s20(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
//         Some(Ok(Token { ttype: TokenType::star, span: (ctx.start_index, self.index) }))
//     }

// // ***  LEXER TABLE END  ***

//     fn sink(&mut self, ctx: Context) -> Option<<Self as Iterator>::Item> {
//         match ctx.last_accept_ttype {
//             LastAcceptTType::Tok(ttype) => {
//                 self.index = ctx.last_accept_index;
//                 Some(Ok(Token { ttype, span: (ctx.start_index, ctx.last_accept_index) }))
//             }
//             LastAcceptTType::Error => {
//                 let pos = self.index;
//                 self.index = usize::MAX; // forces next iteration to return None
//                 Some(Err(ScanError { pos }))
//             }
//             LastAcceptTType::Skip => {
//                 self.index = ctx.last_accept_index;
//                 self.begin()
//             }
//         }
//     }
// }

// pub fn parse<I: AsRef<[u8]> + ?Sized>(input: &I) -> Result<Variable, ParseError> {
//     Parse { input: scan(input), next_token: None }.begin()
// }

// #[derive(Debug, Clone, Copy)]
// pub enum Variable {
//     Expr(ExprProduct),
// }

// pub struct Parse<'a> {
//     input: Scan<'a>,
//     next_token: Option<Token>,
// }

// #[derive(Debug)]
// pub enum ParseError {
//     InputError(ScanError),
//     InvalidAction { state: usize, ttype: Option<TokenType> },
//     InvalidGoto { state: usize },
// }

// impl Parse<'_> {
//     fn begin(mut self) -> Result<Variable, ParseError> {
//         self.update()?;
//         Ok(self.s0()?.0)
//     }

//     fn update(&mut self) -> Result<(), ParseError> {
//         self.next_token = self.input.next().transpose().map_err(|err| { ParseError::InputError(err) })?;
//         Ok(())
//     }

//     fn s0(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s1(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s4() }
//             Some(TokenType::CHAR) => { self.update()?; self.s5() }
//             Some(TokenType::not) => { self.update()?; self.s2() }
//             Some(TokenType::lparen) => { self.update()?; self.s3() }
//             ttype => return Err(ParseError::InvalidAction { state: 0, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s1(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s6(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::string) => { self.update()?; self.s4() }
//             Some(TokenType::CHAR) => { self.update()?; self.s5() }
//             Some(TokenType::and) => { self.update()?; self.s8() }
//             Some(TokenType::or) => { self.update()?; self.s7() }
//             Some(TokenType::diff) => { self.update()?; self.s9() }
//             Some(TokenType::opt) => { self.update()?; self.s10() }
//             Some(TokenType::star) => { self.update()?; self.s11() }
//             Some(TokenType::plus) => { self.update()?; self.s12() }
//             Some(TokenType::not) => { self.update()?; self.s2() }
//             Some(TokenType::lparen) => { self.update()?; self.s3() }
//             ttype => return Err(ParseError::InvalidAction { state: 1, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s2(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s13(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s4() }
//             Some(TokenType::CHAR) => { self.update()?; self.s5() }
//             Some(TokenType::not) => { self.update()?; self.s2() }
//             Some(TokenType::lparen) => { self.update()?; self.s3() }
//             ttype => return Err(ParseError::InvalidAction { state: 2, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s3(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s14(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             ttype => return Err(ParseError::InvalidAction { state: 3, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s4(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 0)),
//             ttype => return Err(ParseError::InvalidAction { state: 4, ttype }),
//         }
//     }
    
//     fn s5(&mut self) -> Result<(Variable, usize), ParseError> {
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::range) => { self.update()?; self.s19() }
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 0)),
//             ttype => return Err(ParseError::InvalidAction { state: 5, ttype }),
//         }?;
//         self.decrement(tuple)
//     }
    
//     fn s6(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s6(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::string) => { self.update()?; self.s4() }
//             Some(TokenType::CHAR) => { self.update()?; self.s5() }
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::opt) => { self.update()?; self.s10() }
//             Some(TokenType::star) => { self.update()?; self.s11() }
//             Some(TokenType::plus) => { self.update()?; self.s12() }
//             Some(TokenType::not) => { self.update()?; self.s2() }
//             Some(TokenType::lparen) => { self.update()?; self.s3() }
//             ttype => return Err(ParseError::InvalidAction { state: 6, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s7(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s20(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s4() }
//             Some(TokenType::CHAR) => { self.update()?; self.s5() }
//             Some(TokenType::not) => { self.update()?; self.s2() }
//             Some(TokenType::lparen) => { self.update()?; self.s3() }
//             ttype => return Err(ParseError::InvalidAction { state: 7, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s8(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s21(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s4() }
//             Some(TokenType::CHAR) => { self.update()?; self.s5() }
//             Some(TokenType::not) => { self.update()?; self.s2() }
//             Some(TokenType::lparen) => { self.update()?; self.s3() }
//             ttype => return Err(ParseError::InvalidAction { state: 8, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s9(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s22(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s4() }
//             Some(TokenType::CHAR) => { self.update()?; self.s5() }
//             Some(TokenType::not) => { self.update()?; self.s2() }
//             Some(TokenType::lparen) => { self.update()?; self.s3() }
//             ttype => return Err(ParseError::InvalidAction { state: 9, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s10(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 1)),
//             ttype => return Err(ParseError::InvalidAction { state: 10, ttype }),
//         }
//     }
    
//     fn s11(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 1)),
//             ttype => return Err(ParseError::InvalidAction { state: 11, ttype }),
//         }
//     }
    
//     fn s12(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 1)),
//             ttype => return Err(ParseError::InvalidAction { state: 12, ttype }),
//         }
//     }
    
//     fn s13(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s6(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::string) => { self.update()?; self.s4() }
//             Some(TokenType::CHAR) => { self.update()?; self.s5() }
//             Some(TokenType::and) => { self.update()?; self.s8() }
//             Some(TokenType::or) => { self.update()?; self.s7() }
//             Some(TokenType::diff) => { self.update()?; self.s9() }
//             Some(TokenType::opt) => { self.update()?; self.s10() }
//             Some(TokenType::star) => { self.update()?; self.s11() }
//             Some(TokenType::plus) => { self.update()?; self.s12() }
//             Some(TokenType::not) => { self.update()?; self.s2() }
//             Some(TokenType::lparen) => { self.update()?; self.s3() }
//             ttype => return Err(ParseError::InvalidAction { state: 13, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s14(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s23(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::and) => { self.update()?; self.s25() }
//             Some(TokenType::or) => { self.update()?; self.s24() }
//             Some(TokenType::diff) => { self.update()?; self.s26() }
//             Some(TokenType::opt) => { self.update()?; self.s27() }
//             Some(TokenType::star) => { self.update()?; self.s28() }
//             Some(TokenType::plus) => { self.update()?; self.s29() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             Some(TokenType::rparen) => { self.update()?; self.s30() }
//             ttype => return Err(ParseError::InvalidAction { state: 14, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s15(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s31(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             ttype => return Err(ParseError::InvalidAction { state: 15, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s16(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s32(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             ttype => return Err(ParseError::InvalidAction { state: 16, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s17(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 0)),
//             ttype => return Err(ParseError::InvalidAction { state: 17, ttype }),
//         }
//     }
    
//     fn s18(&mut self) -> Result<(Variable, usize), ParseError> {
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::range) => { self.update()?; self.s33() }
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 0)),
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 0)),
//             ttype => return Err(ParseError::InvalidAction { state: 18, ttype }),
//         }?;
//         self.decrement(tuple)
//     }
    
//     fn s19(&mut self) -> Result<(Variable, usize), ParseError> {
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::CHAR) => { self.update()?; self.s34() }
//             ttype => return Err(ParseError::InvalidAction { state: 19, ttype }),
//         }?;
//         self.decrement(tuple)
//     }
    
//     fn s20(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s6(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::string) => { self.update()?; self.s4() }
//             Some(TokenType::CHAR) => { self.update()?; self.s5() }
//             Some(TokenType::and) => { self.update()?; self.s8() }
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::diff) => { self.update()?; self.s9() }
//             Some(TokenType::opt) => { self.update()?; self.s10() }
//             Some(TokenType::star) => { self.update()?; self.s11() }
//             Some(TokenType::plus) => { self.update()?; self.s12() }
//             Some(TokenType::not) => { self.update()?; self.s2() }
//             Some(TokenType::lparen) => { self.update()?; self.s3() }
//             ttype => return Err(ParseError::InvalidAction { state: 20, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s21(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s6(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::string) => { self.update()?; self.s4() }
//             Some(TokenType::CHAR) => { self.update()?; self.s5() }
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::opt) => { self.update()?; self.s10() }
//             Some(TokenType::star) => { self.update()?; self.s11() }
//             Some(TokenType::plus) => { self.update()?; self.s12() }
//             Some(TokenType::not) => { self.update()?; self.s2() }
//             Some(TokenType::lparen) => { self.update()?; self.s3() }
//             ttype => return Err(ParseError::InvalidAction { state: 21, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s22(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s6(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::string) => { self.update()?; self.s4() }
//             Some(TokenType::CHAR) => { self.update()?; self.s5() }
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::opt) => { self.update()?; self.s10() }
//             Some(TokenType::star) => { self.update()?; self.s11() }
//             Some(TokenType::plus) => { self.update()?; self.s12() }
//             Some(TokenType::not) => { self.update()?; self.s2() }
//             Some(TokenType::lparen) => { self.update()?; self.s3() }
//             ttype => return Err(ParseError::InvalidAction { state: 22, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s23(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s23(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::opt) => { self.update()?; self.s27() }
//             Some(TokenType::star) => { self.update()?; self.s28() }
//             Some(TokenType::plus) => { self.update()?; self.s29() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 1)),
//             ttype => return Err(ParseError::InvalidAction { state: 23, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s24(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s35(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             ttype => return Err(ParseError::InvalidAction { state: 24, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s25(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s36(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             ttype => return Err(ParseError::InvalidAction { state: 25, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s26(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s37(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             ttype => return Err(ParseError::InvalidAction { state: 26, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s27(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 1)),
//             ttype => return Err(ParseError::InvalidAction { state: 27, ttype }),
//         }
//     }
    
//     fn s28(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 1)),
//             ttype => return Err(ParseError::InvalidAction { state: 28, ttype }),
//         }
//     }
    
//     fn s29(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 1)),
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 1)),
//             ttype => return Err(ParseError::InvalidAction { state: 29, ttype }),
//         }
//     }
    
//     fn s30(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 2)),
//             ttype => return Err(ParseError::InvalidAction { state: 30, ttype }),
//         }
//     }
    
//     fn s31(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s23(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::and) => { self.update()?; self.s25() }
//             Some(TokenType::or) => { self.update()?; self.s24() }
//             Some(TokenType::diff) => { self.update()?; self.s26() }
//             Some(TokenType::opt) => { self.update()?; self.s27() }
//             Some(TokenType::star) => { self.update()?; self.s28() }
//             Some(TokenType::plus) => { self.update()?; self.s29() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 1)),
//             ttype => return Err(ParseError::InvalidAction { state: 31, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s32(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s23(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::and) => { self.update()?; self.s25() }
//             Some(TokenType::or) => { self.update()?; self.s24() }
//             Some(TokenType::diff) => { self.update()?; self.s26() }
//             Some(TokenType::opt) => { self.update()?; self.s27() }
//             Some(TokenType::star) => { self.update()?; self.s28() }
//             Some(TokenType::plus) => { self.update()?; self.s29() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             Some(TokenType::rparen) => { self.update()?; self.s38() }
//             ttype => return Err(ParseError::InvalidAction { state: 32, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s33(&mut self) -> Result<(Variable, usize), ParseError> {
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::CHAR) => { self.update()?; self.s39() }
//             ttype => return Err(ParseError::InvalidAction { state: 33, ttype }),
//         }?;
//         self.decrement(tuple)
//     }
    
//     fn s34(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             None => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 2)),
//             ttype => return Err(ParseError::InvalidAction { state: 34, ttype }),
//         }
//     }
    
//     fn s35(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s23(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::and) => { self.update()?; self.s25() }
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::diff) => { self.update()?; self.s26() }
//             Some(TokenType::opt) => { self.update()?; self.s27() }
//             Some(TokenType::star) => { self.update()?; self.s28() }
//             Some(TokenType::plus) => { self.update()?; self.s29() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 2)),
//             ttype => return Err(ParseError::InvalidAction { state: 35, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s36(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s23(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::opt) => { self.update()?; self.s27() }
//             Some(TokenType::star) => { self.update()?; self.s28() }
//             Some(TokenType::plus) => { self.update()?; self.s29() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 2)),
//             ttype => return Err(ParseError::InvalidAction { state: 36, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s37(&mut self) -> Result<(Variable, usize), ParseError> {
//         fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//             if goto == 0 {
//                 let tuple = match var {
//                     Variable::Expr(_) => parse.s23(),
//                 }?;
//                 on_return(parse, tuple)
//             } else {
//                 Ok((var, goto - 1))
//             }
//         }
//         let tuple = match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => { self.update()?; self.s17() }
//             Some(TokenType::CHAR) => { self.update()?; self.s18() }
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::opt) => { self.update()?; self.s27() }
//             Some(TokenType::star) => { self.update()?; self.s28() }
//             Some(TokenType::plus) => { self.update()?; self.s29() }
//             Some(TokenType::not) => { self.update()?; self.s15() }
//             Some(TokenType::lparen) => { self.update()?; self.s16() }
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 2)),
//             ttype => return Err(ParseError::InvalidAction { state: 37, ttype }),
//         }?;
//         on_return(self, tuple)
//     }
    
//     fn s38(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 2)),
//             ttype => return Err(ParseError::InvalidAction { state: 38, ttype }),
//         }
//     }
    
//     fn s39(&mut self) -> Result<(Variable, usize), ParseError> {
//         match self.next_token.map(|token| token.ttype) {
//             Some(TokenType::string) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::CHAR) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::and) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::or) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::diff) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::opt) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::star) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::plus) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::not) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::lparen) => return Ok((Variable::Expr(0), 2)),
//             Some(TokenType::rparen) => return Ok((Variable::Expr(0), 2)),
//             ttype => return Err(ParseError::InvalidAction { state: 39, ttype }),
//         }
//     }
    
//     fn decrement(&mut self, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
//         assert!(goto > 0);
//         Ok((var, goto - 1))
//     }
// }
