#[allow(non_camel_case_types)]
#[allow(unused_comparisons)]
#[allow(dead_code)]
#[allow(non_snake_case)]
#[allow(unused_mut)]
#[allow(clippy::match_same_arms)]
#[allow(clippy::needless_return)]
#[allow(clippy::unnecessary_wraps)]

type ExprProduct = i32;

// Expr -> Expr or Expr
fn p0(_: ExprProduct, _: Token, _: ExprProduct) -> ExprProduct {
    todo!()
}

// Expr -> Expr and Expr
fn p1(_: ExprProduct, _: Token, _: ExprProduct) -> ExprProduct {
    todo!()
}

// Expr -> Expr diff Expr
fn p2(_: ExprProduct, _: Token, _: ExprProduct) -> ExprProduct {
    todo!()
}

// Expr -> Expr Expr
fn p3(_: ExprProduct, _: ExprProduct) -> ExprProduct {
    todo!()
}

// Expr -> Expr opt
fn p4(_: ExprProduct, _: Token) -> ExprProduct {
    todo!()
}

// Expr -> Expr star
fn p5(_: ExprProduct, _: Token) -> ExprProduct {
    todo!()
}

// Expr -> Expr plus
fn p6(_: ExprProduct, _: Token) -> ExprProduct {
    todo!()
}

// Expr -> not Expr
fn p7(_: Token, _: ExprProduct) -> ExprProduct {
    todo!()
}

// Expr -> lparen Expr rparen
fn p8(_: Token, _: ExprProduct, _: Token) -> ExprProduct {
    todo!()
}

// Expr -> string
fn p9(_: Token) -> ExprProduct {
    todo!()
}

// Expr -> CHAR
fn p10(_: Token) -> ExprProduct {
    todo!()
}

// Expr -> CHAR range CHAR
fn p11(_: Token, _: Token, _: Token) -> ExprProduct {
    todo!()
}

/* automatically generated by sylo */

pub fn scan<I: AsRef<[u8]> + ?Sized>(input: &I) -> Scan<'_> {
    Scan {
        input: input.as_ref(),
        index: 0,
    }
}

pub struct Scan<'a> {
    input: &'a [u8],
    index: usize,
}

#[derive(Debug)]
pub struct ScanError {
    pub pos: usize,
}

#[derive(Debug, Clone, Copy)]
pub enum TokenType {
    string,
    CHAR,
    range,
    and,
    or,
    diff,
    opt,
    star,
    plus,
    not,
    lparen,
    rparen,
}

#[derive(Debug, Clone, Copy)]
pub struct Token {
    pub ttype: TokenType,
    pub span: (usize, usize),
}

pub struct TokenView<'a, T> {
    token: Token,
    input: &'a T
}

impl<'a> Iterator for Scan<'a> {
    type Item = Result<Token, ScanError>;

    fn next(&mut self) -> Option<Self::Item> {
        self.begin()
    }
}

enum LastAcceptTType {
    Tok(TokenType),
    Error,
    Skip,
}

struct Context {
    start_index: usize,
    last_accept_ttype: LastAcceptTType,
    last_accept_index: usize,
}

impl Scan<'_> {
    fn begin(&mut self) -> Option<<Self as Iterator>::Item> {
        if self.index >= self.input.len() {
            return None;
        }

        let ctx = Context {
            start_index: self.index,
            last_accept_ttype: LastAcceptTType::Error,
            last_accept_index: 0,
        };

        self.s0(ctx)
    }

// *** LEXER TABLE START ***

    fn s0(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index >= self.input.len() { return self.sink(&ctx); }
        let ch = self.input[self.index];
        ctx.last_accept_ttype = LastAcceptTType::Skip;
        ctx.last_accept_index = self.index;
        if ch == 0x2a { self.index += 1; return self.s1(ctx); }
        if ch == 0x21 { self.index += 1; return self.s2(ctx); }
        if ch == 0x09 ||
           ch == 0x0a ||
           ch == 0x0d ||
           ch == 0x20 { self.index += 1; return self.s3(ctx); }
        if ch == 0x28 { self.index += 1; return self.s4(ctx); }
        if ch == 0x26 { self.index += 1; return self.s5(ctx); }
        if ch == 0x22 { self.index += 1; return self.s6(ctx); }
        if ch == 0x29 { self.index += 1; return self.s10(ctx); }
        if ch == 0x7c { self.index += 1; return self.s11(ctx); }
        if ch == 0x3f { self.index += 1; return self.s12(ctx); }
        if ch == 0x2d { self.index += 1; return self.s13(ctx); }
        if ch == 0x2e { self.index += 1; return self.s14(ctx); }
        if ch == 0x2b { self.index += 1; return self.s16(ctx); }
        if ch == 0x27 { self.index += 1; return self.s17(ctx); }
        self.begin()
    }

    fn s1(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::star, span: (ctx.start_index, self.index) }))
    }

    fn s2(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::not, span: (ctx.start_index, self.index) }))
    }

    fn s3(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index >= self.input.len() { return self.sink(&ctx); }
        let ch = self.input[self.index];
        if ch == 0x09 ||
           ch == 0x0a ||
           ch == 0x0d ||
           ch == 0x20 { self.index += 1; return self.s3(ctx); }
        self.begin()
    }

    fn s4(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::lparen, span: (ctx.start_index, self.index) }))
    }

    fn s5(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::and, span: (ctx.start_index, self.index) }))
    }

    fn s6(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index >= self.input.len() { return self.sink(&ctx); }
        let ch = self.input[self.index];
        if ch == 0x09 ||
           ch == 0x0a ||
           ch == 0x0d ||
           ch == 0x20 ||
           ch == 0x21 ||
           (0x23..=0x5b).contains(&ch) ||
           (0x5d..=0x7e).contains(&ch) ||
           (0xa0..=0xff).contains(&ch) { self.index += 1; return self.s7(ctx); }
        if ch == 0x5c { self.index += 1; return self.s8(ctx); }
        self.sink(&ctx)
    }

    fn s7(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index >= self.input.len() { return self.sink(&ctx); }
        let ch = self.input[self.index];
        if ch == 0x09 ||
           ch == 0x0a ||
           ch == 0x0d ||
           ch == 0x20 ||
           ch == 0x21 ||
           (0x23..=0x5b).contains(&ch) ||
           (0x5d..=0x7e).contains(&ch) ||
           (0xa0..=0xff).contains(&ch) { self.index += 1; return self.s7(ctx); }
        if ch == 0x5c { self.index += 1; return self.s8(ctx); }
        if ch == 0x22 { self.index += 1; return self.s9(ctx); }
        self.sink(&ctx)
    }

    fn s8(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index >= self.input.len() { return self.sink(&ctx); }
        let ch = self.input[self.index];
        if ch == 0x22 ||
           ch == 0x5c { self.index += 1; return self.s7(ctx); }
        self.sink(&ctx)
    }

    fn s9(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::string, span: (ctx.start_index, self.index) }))
    }

    fn s10(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::rparen, span: (ctx.start_index, self.index) }))
    }

    fn s11(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::or, span: (ctx.start_index, self.index) }))
    }

    fn s12(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::opt, span: (ctx.start_index, self.index) }))
    }

    fn s13(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::diff, span: (ctx.start_index, self.index) }))
    }

    fn s14(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index >= self.input.len() { return self.sink(&ctx); }
        let ch = self.input[self.index];
        if ch == 0x2e { self.index += 1; return self.s15(ctx); }
        self.sink(&ctx)
    }

    fn s15(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::range, span: (ctx.start_index, self.index) }))
    }

    fn s16(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::plus, span: (ctx.start_index, self.index) }))
    }

    fn s17(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index >= self.input.len() { return self.sink(&ctx); }
        let ch = self.input[self.index];
        if ch == 0x09 ||
           ch == 0x0a ||
           ch == 0x0d ||
           ch == 0x20 ||
           ch == 0x21 ||
           (0x23..=0x5b).contains(&ch) ||
           (0x5d..=0x7e).contains(&ch) ||
           (0xa0..=0xff).contains(&ch) { self.index += 1; return self.s18(ctx); }
        if ch == 0x5c { self.index += 1; return self.s20(ctx); }
        self.sink(&ctx)
    }

    fn s18(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index >= self.input.len() { return self.sink(&ctx); }
        let ch = self.input[self.index];
        if ch == 0x27 { self.index += 1; return self.s19(ctx); }
        self.sink(&ctx)
    }

    fn s19(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::CHAR, span: (ctx.start_index, self.index) }))
    }

    fn s20(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index >= self.input.len() { return self.sink(&ctx); }
        let ch = self.input[self.index];
        if ch == 0x22 ||
           ch == 0x5c { self.index += 1; return self.s18(ctx); }
        self.sink(&ctx)
    }

// ***  LEXER TABLE END  ***

    fn sink(&mut self, ctx: &Context) -> Option<<Self as Iterator>::Item> {
        match ctx.last_accept_ttype {
            LastAcceptTType::Tok(ttype) => {
                self.index = ctx.last_accept_index;
                Some(Ok(Token { ttype, span: (ctx.start_index, ctx.last_accept_index) }))
            }
            LastAcceptTType::Error => {
                let pos = self.index;
                self.index = usize::MAX; // forces next iteration to return None
                Some(Err(ScanError { pos }))
            }
            LastAcceptTType::Skip => {
                self.index = ctx.last_accept_index;
                self.begin()
            }
        }
    }
}

pub fn parse<I: AsRef<[u8]> + ?Sized>(input: &I) -> Result<Variable, ParseError> {
    Parse { input: scan(input), next_token: None }.begin()
}

#[derive(Debug, Clone, Copy)]
pub enum Variable {
    Expr(ExprProduct),
}

pub struct Parse<'a> {
    input: Scan<'a>,
    next_token: Option<Token>,
}

#[derive(Debug)]
pub enum ParseError {
    InputError(ScanError),
    InvalidAction { state: usize, ttype: Option<TokenType> },
    InvalidGoto { state: usize },
}

impl Parse<'_> {
    fn begin(mut self) -> Result<Variable, ParseError> {
        self.update()?;
        Ok(self.s0()?.0)
    }

    fn update(&mut self) -> Result<(), ParseError> {
        self.next_token = self.input.next().transpose().map_err(|err| { ParseError::InputError(err) })?;
        Ok(())
    }

    fn s0(&mut self) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s1(v),
                }?;
                on_return(parse, tuple)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s4(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s5(t) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s2(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s3(t) }
            token => return Err(ParseError::InvalidAction { state: 0, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple)
    }
    
    fn s1(&mut self, arg: ExprProduct) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), arg: ExprProduct) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s6((arg, v)),
                }?;
                on_return(parse, tuple, arg)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            None => return Ok((Variable::Expr(0), 1)),
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s4(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s5(t) }
            Some(t @ Token { ttype: TokenType::and, .. }) => { self.update()?; self.s8((arg, t)) }
            Some(t @ Token { ttype: TokenType::or, .. }) => { self.update()?; self.s7((arg, t)) }
            Some(t @ Token { ttype: TokenType::diff, .. }) => { self.update()?; self.s9((arg, t)) }
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s10((arg, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s11((arg, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s12((arg, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s2(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s3(t) }
            token => return Err(ParseError::InvalidAction { state: 1, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, arg)
    }
    
    fn s2(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), arg: Token) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s13((arg, v)),
                }?;
                on_return(parse, tuple, arg)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s4(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s5(t) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s2(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s3(t) }
            token => return Err(ParseError::InvalidAction { state: 2, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, arg)
    }
    
    fn s3(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), arg: Token) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s14((arg, v)),
                }?;
                on_return(parse, tuple, arg)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            token => return Err(ParseError::InvalidAction { state: 3, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, arg)
    }
    
    fn s4(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            None => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            token => return Err(ParseError::InvalidAction { state: 4, ttype: token.map(|token| token.ttype) }),
        }
    }
    
    fn s5(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        let tuple = match self.next_token {
            None => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(t @ Token { ttype: TokenType::range, .. }) => { self.update()?; self.s19((arg, t)) }
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            token => return Err(ParseError::InvalidAction { state: 5, ttype: token.map(|token| token.ttype) }),
        }?;
        decrement(tuple)
    }
    
    fn s6(&mut self, args: (ExprProduct, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s6((args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            None => return Ok((Variable::Expr(p3(args.0, args.1)), 1)),
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s4(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s5(t) }
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p3(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p3(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p3(args.0, args.1)), 1)),
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s10((args.1, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s11((args.1, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s12((args.1, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s2(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s3(t) }
            token => return Err(ParseError::InvalidAction { state: 6, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s7(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s20((args.0, args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s4(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s5(t) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s2(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s3(t) }
            token => return Err(ParseError::InvalidAction { state: 7, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s8(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s21((args.0, args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s4(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s5(t) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s2(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s3(t) }
            token => return Err(ParseError::InvalidAction { state: 8, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s9(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s22((args.0, args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s4(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s5(t) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s2(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s3(t) }
            token => return Err(ParseError::InvalidAction { state: 9, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s10(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            None => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            token => return Err(ParseError::InvalidAction { state: 10, ttype: token.map(|token| token.ttype) }),
        }
    }
    
    fn s11(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            None => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            token => return Err(ParseError::InvalidAction { state: 11, ttype: token.map(|token| token.ttype) }),
        }
    }
    
    fn s12(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            None => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            token => return Err(ParseError::InvalidAction { state: 12, ttype: token.map(|token| token.ttype) }),
        }
    }
    
    fn s13(&mut self, args: (Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s6((args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            None => return Ok((Variable::Expr(p7(args.0, args.1)), 1)),
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s4(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s5(t) }
            Some(t @ Token { ttype: TokenType::and, .. }) => { self.update()?; self.s8((args.1, t)) }
            Some(t @ Token { ttype: TokenType::or, .. }) => { self.update()?; self.s7((args.1, t)) }
            Some(t @ Token { ttype: TokenType::diff, .. }) => { self.update()?; self.s9((args.1, t)) }
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s10((args.1, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s11((args.1, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s12((args.1, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s2(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s3(t) }
            token => return Err(ParseError::InvalidAction { state: 13, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s14(&mut self, args: (Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s23((args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(t @ Token { ttype: TokenType::and, .. }) => { self.update()?; self.s25((args.1, t)) }
            Some(t @ Token { ttype: TokenType::or, .. }) => { self.update()?; self.s24((args.1, t)) }
            Some(t @ Token { ttype: TokenType::diff, .. }) => { self.update()?; self.s26((args.1, t)) }
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s27((args.1, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s28((args.1, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s29((args.1, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            Some(t @ Token { ttype: TokenType::rparen, .. }) => { self.update()?; self.s30((args.0, args.1, t)) }
            token => return Err(ParseError::InvalidAction { state: 14, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s15(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), arg: Token) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s31((arg, v)),
                }?;
                on_return(parse, tuple, arg)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            token => return Err(ParseError::InvalidAction { state: 15, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, arg)
    }
    
    fn s16(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), arg: Token) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s32((arg, v)),
                }?;
                on_return(parse, tuple, arg)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            token => return Err(ParseError::InvalidAction { state: 16, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, arg)
    }
    
    fn s17(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p9(arg)), 0)),
            token => return Err(ParseError::InvalidAction { state: 17, ttype: token.map(|token| token.ttype) }),
        }
    }
    
    fn s18(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        let tuple = match self.next_token {
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(t @ Token { ttype: TokenType::range, .. }) => { self.update()?; self.s33((arg, t)) }
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p10(arg)), 0)),
            token => return Err(ParseError::InvalidAction { state: 18, ttype: token.map(|token| token.ttype) }),
        }?;
        decrement(tuple)
    }
    
    fn s19(&mut self, args: (Token, Token)) -> Result<(Variable, usize), ParseError> {
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s34((args.0, args.1, t)) }
            token => return Err(ParseError::InvalidAction { state: 19, ttype: token.map(|token| token.ttype) }),
        }?;
        decrement(tuple)
    }
    
    fn s20(&mut self, args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s6((args.2, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            None => return Ok((Variable::Expr(p0(args.0, args.1, args.2)), 2)),
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s4(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s5(t) }
            Some(t @ Token { ttype: TokenType::and, .. }) => { self.update()?; self.s8((args.2, t)) }
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p0(args.0, args.1, args.2)), 2)),
            Some(t @ Token { ttype: TokenType::diff, .. }) => { self.update()?; self.s9((args.2, t)) }
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s10((args.2, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s11((args.2, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s12((args.2, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s2(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s3(t) }
            token => return Err(ParseError::InvalidAction { state: 20, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s21(&mut self, args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s6((args.2, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            None => return Ok((Variable::Expr(p1(args.0, args.1, args.2)), 2)),
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s4(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s5(t) }
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p1(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p1(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p1(args.0, args.1, args.2)), 2)),
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s10((args.2, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s11((args.2, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s12((args.2, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s2(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s3(t) }
            token => return Err(ParseError::InvalidAction { state: 21, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s22(&mut self, args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s6((args.2, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            None => return Ok((Variable::Expr(p2(args.0, args.1, args.2)), 2)),
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s4(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s5(t) }
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p2(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p2(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p2(args.0, args.1, args.2)), 2)),
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s10((args.2, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s11((args.2, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s12((args.2, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s2(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s3(t) }
            token => return Err(ParseError::InvalidAction { state: 22, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s23(&mut self, args: (ExprProduct, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s23((args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p3(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p3(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p3(args.0, args.1)), 1)),
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s27((args.1, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s28((args.1, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s29((args.1, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p3(args.0, args.1)), 1)),
            token => return Err(ParseError::InvalidAction { state: 23, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s24(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s35((args.0, args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            token => return Err(ParseError::InvalidAction { state: 24, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s25(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s36((args.0, args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            token => return Err(ParseError::InvalidAction { state: 25, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s26(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s37((args.0, args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            token => return Err(ParseError::InvalidAction { state: 26, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s27(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p4(args.0, args.1)), 1)),
            token => return Err(ParseError::InvalidAction { state: 27, ttype: token.map(|token| token.ttype) }),
        }
    }
    
    fn s28(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p5(args.0, args.1)), 1)),
            token => return Err(ParseError::InvalidAction { state: 28, ttype: token.map(|token| token.ttype) }),
        }
    }
    
    fn s29(&mut self, args: (ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p6(args.0, args.1)), 1)),
            token => return Err(ParseError::InvalidAction { state: 29, ttype: token.map(|token| token.ttype) }),
        }
    }
    
    fn s30(&mut self, args: (Token, ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            None => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            token => return Err(ParseError::InvalidAction { state: 30, ttype: token.map(|token| token.ttype) }),
        }
    }
    
    fn s31(&mut self, args: (Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s23((args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(t @ Token { ttype: TokenType::and, .. }) => { self.update()?; self.s25((args.1, t)) }
            Some(t @ Token { ttype: TokenType::or, .. }) => { self.update()?; self.s24((args.1, t)) }
            Some(t @ Token { ttype: TokenType::diff, .. }) => { self.update()?; self.s26((args.1, t)) }
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s27((args.1, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s28((args.1, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s29((args.1, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p7(args.0, args.1)), 1)),
            token => return Err(ParseError::InvalidAction { state: 31, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s32(&mut self, args: (Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s23((args.1, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(t @ Token { ttype: TokenType::and, .. }) => { self.update()?; self.s25((args.1, t)) }
            Some(t @ Token { ttype: TokenType::or, .. }) => { self.update()?; self.s24((args.1, t)) }
            Some(t @ Token { ttype: TokenType::diff, .. }) => { self.update()?; self.s26((args.1, t)) }
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s27((args.1, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s28((args.1, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s29((args.1, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            Some(t @ Token { ttype: TokenType::rparen, .. }) => { self.update()?; self.s38((args.0, args.1, t)) }
            token => return Err(ParseError::InvalidAction { state: 32, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s33(&mut self, args: (Token, Token)) -> Result<(Variable, usize), ParseError> {
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s39((args.0, args.1, t)) }
            token => return Err(ParseError::InvalidAction { state: 33, ttype: token.map(|token| token.ttype) }),
        }?;
        decrement(tuple)
    }
    
    fn s34(&mut self, args: (Token, Token, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            None => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            token => return Err(ParseError::InvalidAction { state: 34, ttype: token.map(|token| token.ttype) }),
        }
    }
    
    fn s35(&mut self, args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s23((args.2, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(t @ Token { ttype: TokenType::and, .. }) => { self.update()?; self.s25((args.2, t)) }
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p0(args.0, args.1, args.2)), 2)),
            Some(t @ Token { ttype: TokenType::diff, .. }) => { self.update()?; self.s26((args.2, t)) }
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s27((args.2, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s28((args.2, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s29((args.2, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p0(args.0, args.1, args.2)), 2)),
            token => return Err(ParseError::InvalidAction { state: 35, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s36(&mut self, args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s23((args.2, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p1(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p1(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p1(args.0, args.1, args.2)), 2)),
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s27((args.2, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s28((args.2, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s29((args.2, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p1(args.0, args.1, args.2)), 2)),
            token => return Err(ParseError::InvalidAction { state: 36, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s37(&mut self, args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (ExprProduct, Token, ExprProduct)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::Expr(v) => parse.s23((args.2, v)),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::string, .. }) => { self.update()?; self.s17(t) }
            Some(t @ Token { ttype: TokenType::CHAR, .. }) => { self.update()?; self.s18(t) }
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p2(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p2(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p2(args.0, args.1, args.2)), 2)),
            Some(t @ Token { ttype: TokenType::opt, .. }) => { self.update()?; self.s27((args.2, t)) }
            Some(t @ Token { ttype: TokenType::star, .. }) => { self.update()?; self.s28((args.2, t)) }
            Some(t @ Token { ttype: TokenType::plus, .. }) => { self.update()?; self.s29((args.2, t)) }
            Some(t @ Token { ttype: TokenType::not, .. }) => { self.update()?; self.s15(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s16(t) }
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p2(args.0, args.1, args.2)), 2)),
            token => return Err(ParseError::InvalidAction { state: 37, ttype: token.map(|token| token.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s38(&mut self, args: (Token, ExprProduct, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p8(args.0, args.1, args.2)), 2)),
            token => return Err(ParseError::InvalidAction { state: 38, ttype: token.map(|token| token.ttype) }),
        }
    }
    
    fn s39(&mut self, args: (Token, Token, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            Some(Token { ttype: TokenType::string, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::CHAR, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::and, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::or, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::diff, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::opt, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::star, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::plus, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::not, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::lparen, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::Expr(p11(args.0, args.1, args.2)), 2)),
            token => return Err(ParseError::InvalidAction { state: 39, ttype: token.map(|token| token.ttype) }),
        }
    }
}

fn decrement((var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
    assert!(goto > 0);
    Ok((var, goto - 1))
}
