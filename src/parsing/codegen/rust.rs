#![allow(clippy::match_on_vec_items)]
#![allow(non_snake_case)]

use std::fmt::Write;
use crate::utils::IndentWriter;
use crate::langcore::cfg::Symbol;
use crate::langcore::re::Command;
use crate::langcore::lr1_table::Action;
use super::rep;

impl rep::Lexer {
    /// # Errors
    #[allow(clippy::too_many_lines)]
    pub fn to_rust<W: Write>(&self, fmt: W) -> Result<W, std::fmt::Error> {
        let mut fmt = IndentWriter::new(fmt);

        writeln!(fmt, "/* automatically generated by sylo */")?;
        writeln!(fmt)?;
        writeln!(fmt, "pub fn scan<I: AsRef<[u8]> + ?Sized>(input: &I) -> Scan<'_> {{")?;
        writeln!(fmt, "    Scan {{")?;
        writeln!(fmt, "        input: input.as_ref(),")?;
        writeln!(fmt, "        index: 0,")?;
        writeln!(fmt, "    }}")?;
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "pub struct Scan<'a> {{")?;
        writeln!(fmt, "    input: &'a [u8],")?;
        writeln!(fmt, "    index: usize,")?;
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "#[derive(Debug)]")?;
        writeln!(fmt, "pub struct ScanError {{")?;
        writeln!(fmt, "    pub pos: usize,")?;
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "#[derive(Debug, Clone, Copy)]")?;
        writeln!(fmt, "pub enum TokenType {{")?;
        for ttype in self.ttypes.iter().zip(&self.commands).filter_map(|(ttype, command)| if let Command::Emit = command { Some(ttype) } else { None }) {
            writeln!(fmt, "    {ttype},", ttype=ttype)?;
        }
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "#[derive(Debug, Clone, Copy)]")?;
        writeln!(fmt, "pub struct Token {{")?;
        writeln!(fmt, "    pub ttype: TokenType,")?;
        writeln!(fmt, "    pub span: (usize, usize),")?;
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "pub struct TokenView<'a, T> {{")?;
        writeln!(fmt, "    token: Token,")?;
        writeln!(fmt, "    input: &'a T")?;
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "impl<'a> Iterator for Scan<'a> {{")?;
        writeln!(fmt, "    type Item = Result<Token, ScanError>;")?;
        writeln!(fmt)?;
        writeln!(fmt, "    fn next(&mut self) -> Option<Self::Item> {{")?;
        writeln!(fmt, "        self.begin()")?;
        writeln!(fmt, "    }}")?;
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "enum LastAcceptTType {{")?;
        writeln!(fmt, "    Tok(TokenType),")?;
        writeln!(fmt, "    Error,")?;
        writeln!(fmt, "    Skip,")?;
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "struct Context {{")?;
        writeln!(fmt, "    start_index: usize,")?;
        writeln!(fmt, "    last_accept_ttype: LastAcceptTType,")?;
        writeln!(fmt, "    last_accept_index: usize,")?;
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "impl Scan<'_> {{")?;
        writeln!(fmt, "    fn begin(&mut self) -> Option<<Self as Iterator>::Item> {{")?;
        writeln!(fmt, "        if self.index >= self.input.len() {{")?;
        writeln!(fmt, "            return None;")?;
        writeln!(fmt, "        }}")?;
        writeln!(fmt)?;
        writeln!(fmt, "        let ctx = Context {{")?;
        writeln!(fmt, "            start_index: self.index,")?;
        writeln!(fmt, "            last_accept_ttype: LastAcceptTType::Error,")?;
        writeln!(fmt, "            last_accept_index: 0,")?;
        writeln!(fmt, "        }};")?;
        writeln!(fmt)?;
        writeln!(fmt, "        self.s0(ctx)")?;
        writeln!(fmt, "    }}")?;
        writeln!(fmt)?;
        writeln!(fmt, "// *** LEXER TABLE START ***")?;
        writeln!(fmt)?;
        fmt.indent();
        for (i, state) in self.states.iter().enumerate() {
            writeln!(fmt, "fn s{}(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {{", i)?;
            fmt.indent();

            if state.transitions.is_empty() {
                // `i` is a labelled state
                if let Some(class) = state.class {
                    if let Command::Skip = self.commands[class] {
                        writeln!(fmt, "self.begin()")?;
                    } else {
                        writeln!(fmt, "Some(Ok(Token {{ ttype: TokenType::{ttype}, span: (ctx.start_index, self.index) }}))", ttype=self.ttypes[class])?;
                    }
                } else {
                    writeln!(fmt, "self.sink(&ctx)")?;
                }
            } else {
                writeln!(fmt, "if self.index >= self.input.len() {{ return self.sink(&ctx); }}")?;
                writeln!(fmt, "let ch = self.input[self.index];")?;
                // writeln!(fmt, "NEXT_CHAR(ch)")?;

                // `i` is a labelled state
                if let Some(class) = state.class {
                    let ttype = if let Command::Skip = self.commands[class] {
                        "LastAcceptTType::Skip".to_string()
                    } else {
                        format!("LastAcceptTType::Tok(TokenType::{ttype})", ttype=self.ttypes[class])
                    };

                    // If `i` can only transition to labelled states, then either
                    // its corresponding token will be returned immediately or the
                    // token of any destination state will take priority (due to
                    // maximal munch). As such, there would be no need for the
                    // last accept token type or index to be stored. 
                    if state.can_transition_to_unlabelled_state {
                        writeln!(fmt, "ctx.last_accept_ttype = {ttype};", ttype=ttype)?;
                        writeln!(fmt, "ctx.last_accept_index = self.index;")?;
                    }
                }

                // Transitions to non-sink states. Semantically speaking, if any no
                // transition is taken, then we transition to the sink state.
                for rep::Transition { intervals, dst } in &state.transitions {
                    write!(fmt, "if ")?;

                    for (i, &(start, end)) in intervals.iter().enumerate() {
                        if i > 0 {
                            write!(fmt, "   ")?;
                        }

                        #[allow(clippy::comparison_chain)]
                        if start + 1 < end {
                            // write!(fmt, "(0x{:02x?} <= ch && ch <= 0x{:02x?})", start, end)?;
                            write!(fmt, "(0x{:02x?}..=0x{:02x?}).contains(&ch)", start, end)?;
                        } else if start + 1 == end {
                            writeln!(fmt, "ch == 0x{:02x?} ||", start)?;
                            write!(fmt, "   ch == 0x{:02x?}", end)?;
                        } else {
                            write!(fmt, "ch == 0x{:02x?}", start)?;
                        }

                        if i < intervals.len() - 1 {
                            writeln!(fmt, " ||")?;
                        }
                    }

                    writeln!(fmt, " {{ self.index += 1; return self.s{dst}(ctx); }}", dst=dst)?;
                    // writeln!(fmt, ") GOTO({});", dst)?;
                }
                
                // `i` is a labelled state
                if let Some(class) = state.class {
                    if let Command::Skip = self.commands[class] {
                        writeln!(fmt, "self.begin()")?;
                    } else {
                        writeln!(fmt, "Some(Ok(Token {{ ttype: TokenType::{ttype}, span: (ctx.start_index, self.index) }}))", ttype=self.ttypes[class])?;
                    }
                } else {
                    writeln!(fmt, "self.sink(&ctx)")?;
                }
            }

            fmt.unindent();
            writeln!(fmt, "}}\n")?;
        }
        fmt.unindent();
        writeln!(fmt, "// ***  LEXER TABLE END  ***")?;
        writeln!(fmt)?;
        writeln!(fmt, "    fn sink(&mut self, ctx: &Context) -> Option<<Self as Iterator>::Item> {{")?;
        writeln!(fmt, "        match ctx.last_accept_ttype {{")?;
        writeln!(fmt, "            LastAcceptTType::Tok(ttype) => {{")?;
        writeln!(fmt, "                self.index = ctx.last_accept_index;")?;
        writeln!(fmt, "                Some(Ok(Token {{ ttype, span: (ctx.start_index, ctx.last_accept_index) }}))")?;
        writeln!(fmt, "            }}")?;
        writeln!(fmt, "            LastAcceptTType::Error => {{")?;
        writeln!(fmt, "                let pos = self.index;")?;
        writeln!(fmt, "                self.index = usize::MAX; // forces next iteration to return None")?;
        writeln!(fmt, "                Some(Err(ScanError {{ pos }}))")?;
        writeln!(fmt, "            }}")?;
        writeln!(fmt, "            LastAcceptTType::Skip => {{")?;
        writeln!(fmt, "                self.index = ctx.last_accept_index;")?;
        writeln!(fmt, "                self.begin()")?;
        writeln!(fmt, "            }}")?;
        writeln!(fmt, "        }}")?;
        writeln!(fmt, "    }}")?;
        writeln!(fmt, "}}")?;
        
        Ok(fmt.build())
    }
}

impl rep::LR1Parser {
    /// # Errors
    /// # Panics
    #[allow(clippy::too_many_lines)]
    pub fn to_rust<W: Write>(&self, fmt: W) -> Result<W, std::fmt::Error> {
        let mut fmt = IndentWriter::new(fmt);

        writeln!(fmt, "#![allow(non_camel_case_types)]")?;
        writeln!(fmt, "#![allow(unused_comparisons)]")?;
        writeln!(fmt, "#![allow(dead_code)]")?;
        writeln!(fmt, "#![allow(non_snake_case)]")?;
        writeln!(fmt, "#![allow(unused_mut)]")?;
        writeln!(fmt, "#![allow(clippy::match_same_arms)]")?;
        writeln!(fmt, "#![allow(clippy::needless_return)]")?;
        writeln!(fmt, "#![allow(clippy::unnecessary_wraps)]")?;
        writeln!(fmt, "#![allow(clippy::unit_arg)]")?;
        writeln!(fmt)?;

        // =====================
        // === product types ===
        // =====================

        for varname in &self.varnames {
            writeln!(fmt, "type {varname}Product = ();", varname=varname)?; // TODO: product type is configurable per variable
        }
        writeln!(fmt)?;
        
        // ============================
        // === production callbacks ===
        // ============================

        let productions = self.reductions[..self.reductions.len()-1].iter().map(|reduction| reduction.var)
            .zip(self.grammar.rules().flat_map(|rule| rule.alts()));
        for (i, (lhs, rhs)) in productions.enumerate() {
            if lhs < self.grammar.var_count() - 1 { // ignore the augmented grammar rule
                // write comment
                write!(fmt, "// {varname} ->", varname=self.varnames[lhs])?;
                for &symbol in rhs {
                    match symbol {
                        Symbol::Terminal(a) => write!(fmt, " {}", self.lexer.ttypes[a])?,
                        Symbol::Variable(A) => write!(fmt, " {}", self.varnames[A])?,
                    }
                }
                writeln!(fmt)?;

                // write function signature
                write!(fmt, "fn p{i}(", i=i)?;
                for (i, &symbol) in rhs.iter().enumerate() {
                    match symbol {
                        Symbol::Terminal(_) => write!(fmt, "_: &[u8]")?,
                        Symbol::Variable(A) => write!(fmt, "_: {varname}Product", varname=self.varnames[A])?,
                    }
                    if i < rhs.len()-1 {
                        write!(fmt, ", ")?;
                    }
                }
                writeln!(fmt, ") -> {varname}Product {{", varname=self.varnames[lhs])?;
                writeln!(fmt, "    todo!()")?;
                writeln!(fmt, "}}\n")?;
            }
        }

        // =============
        // === lexer ===
        // =============

        let mut fmt = self.lexer.to_rust(fmt)?;
        writeln!(fmt)?;

        // ==========================
        // === parser boilerplate ===
        // ==========================

        writeln!(fmt, "pub fn parse<I: AsRef<[u8]> + ?Sized>(input: &I) -> Result<Variable, ParseError> {{")?;
        writeln!(fmt, "    Parse {{ input: scan(input), next_token: None }}.begin()")?;
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "#[derive(Debug, Clone, Copy)]")?;
        writeln!(fmt, "pub enum Variable {{")?;
        for varname in &self.varnames {
            writeln!(fmt, "    {varname}({varname}Product),", varname=varname)?; // TODO: product type is configurable per variable
        }
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "pub struct Parse<'a> {{")?;
        writeln!(fmt, "    input: Scan<'a>,")?;
        writeln!(fmt, "    next_token: Option<Token>,")?;
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "#[derive(Debug)]")?;
        writeln!(fmt, "pub enum ParseError {{")?;
        writeln!(fmt, "    InputError(ScanError),")?;
        writeln!(fmt, "    InvalidAction {{ state: usize, ttype: Option<TokenType> }},")?;
        writeln!(fmt, "    InvalidGoto {{ state: usize }},")?;
        writeln!(fmt, "}}")?;
        writeln!(fmt)?;
        writeln!(fmt, "impl Parse<'_> {{")?;
        writeln!(fmt, "    fn begin(mut self) -> Result<Variable, ParseError> {{")?;
        writeln!(fmt, "        self.update()?;")?;
        writeln!(fmt, "        Ok(self.s0()?.0)")?;
        writeln!(fmt, "    }}")?;
        writeln!(fmt)?;
        writeln!(fmt, "    fn update(&mut self) -> Result<(), ParseError> {{")?;
        writeln!(fmt, "        self.next_token = self.input.next().transpose().map_err(|err| {{ ParseError::InputError(err) }})?;")?;
        writeln!(fmt, "        Ok(())")?;
        writeln!(fmt, "    }}")?;
        writeln!(fmt)?;
        
        // ==============================
        // === parser state functions ===
        // ==============================
        
        let mut uses_decrement = false;
        {
            fmt.indent();
            for (i, state) in self.states.iter().enumerate() {
                let arg = match state.input_symbols.len() {
                    x if x > 1 => {
                        let arg_types: Vec<_> = state.input_symbols.iter().map(|&symbol| {
                            match symbol {
                                Symbol::Terminal(_) => "Token".to_string(),
                                Symbol::Variable(A) => format!("{varname}Product", varname=self.varnames[A]),
                            }
                        }).collect();
                        Some(("args", format!("({})", arg_types.join(", "))))
                    }
                    x if x == 1 => {
                        Some(("arg", match state.input_symbols[0] {
                            Symbol::Terminal(_) => "Token".to_string(),
                            Symbol::Variable(A) => format!("{varname}Product", varname=self.varnames[A]),
                        }))
                    }
                    _ => {
                        None
                    }
                };

                // state function signature
                match arg {
                    Some((name, ref r#type)) => writeln!(fmt, "fn s{}(&mut self, {argname}: {argtype}) -> Result<(Variable, usize), ParseError> {{", i, argname=name, argtype=r#type)?,
                    None => writeln!(fmt, "fn s{}(&mut self) -> Result<(Variable, usize), ParseError> {{", i)?,
                }
                fmt.indent();

                if !state.ttrans.is_empty() {
                    if state.has_shift_transitions {
                        if state.nttrans.is_empty() {
                            uses_decrement = true;
                        } else {
                            // on_return function definition
                            match arg {
                                Some((name, ref r#type)) => writeln!(fmt, "fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), {argname}: {argtype}) -> Result<(Variable, usize), ParseError> {{", argname=name, argtype=r#type)?,
                                None => writeln!(fmt, "fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {{")?,
                            }

                            {
                                fmt.indent();
                                writeln!(fmt, "if goto == 0 {{")?;
                                {
                                    fmt.indent();
                                    writeln!(fmt, "let tuple = match var {{")?;
                                    for nttran in &state.nttrans {
                                        let dst = nttran.dst;
                                        write!(fmt, "    Variable::{varname}(v) => parse.s{dst}(", varname=self.varnames[nttran.var], dst=dst)?;
                                        arglist(&mut fmt, state, &self.states[dst], "v")?;
                                        writeln!(fmt, "),")?;
                                    }
                                    if state.nttrans.len() < self.varnames.len() {
                                        writeln!(fmt, "    _ => return Err(ParseError::InvalidGoto {{ state: {state} }}),", state=i)?;
                                    }
                                    writeln!(fmt, "}}?;")?;
                                    match arg {
                                        Some((name, _)) => writeln!(fmt, "on_return(parse, tuple, {argname})", argname=name)?,
                                        None => writeln!(fmt, "on_return(parse, tuple)")?,
                                    }
                                    fmt.unindent();
                                }
                                writeln!(fmt, "}} else {{")?;
                                writeln!(fmt, "    Ok((var, goto - 1))")?;
                                writeln!(fmt, "}}")?;
                                fmt.unindent();
                            }
                            
                            writeln!(fmt, "}}")?;
                        }

                        write!(fmt, "let tuple = ")?;   
                    }

                    writeln!(fmt, "match self.next_token {{")?;
                    {
                        fmt.indent();
                        for ttran in &state.ttrans {
                            match ttran.action {
                                Action::Invalid => panic!(),
                                Action::Accept => {
                                    match ttran.word {
                                        Some(word) => write!(fmt, "Some(Token {{ ttype: TokenType::{ttype}, .. }}) => ", ttype=self.lexer.ttypes[word])?,
                                        None => write!(fmt, "None => ")?,
                                    }
                                    writeln!(fmt, "return Ok((Variable::{varname}(arg), 1)),", varname=self.varnames[0])?;
                                }
                                Action::Shift(dst) => {
                                    match ttran.word {
                                        Some(word) => write!(fmt, "Some(t @ Token {{ ttype: TokenType::{ttype}, .. }}) => ", ttype=self.lexer.ttypes[word])?,
                                        None => write!(fmt, "None => ")?,
                                    }
                                    write!(fmt, "{{ self.update()?; self.s{dst}(", dst=dst)?;
                                    arglist(&mut fmt, state, &self.states[dst], "t")?;
                                    writeln!(fmt, ") }}")?;
                                }
                                Action::Reduce(p) => {
                                    match ttran.word {
                                        Some(word) => write!(fmt, "Some(Token {{ ttype: TokenType::{ttype}, .. }}) => ", ttype=self.lexer.ttypes[word])?,
                                        None => write!(fmt, "None => ")?,
                                    }
                                    let r = self.reductions[p];
                                    write!(fmt, "return Ok((Variable::{varname}(p{i}(", varname=self.varnames[r.var], i=p)?;
                                    let input_symbols = &state.input_symbols;
                                    let alt = self.grammar.alt(p);
                                    let offset = input_symbols.len() - alt.len();
                                    for i in offset..input_symbols.len() {
                                        let arg = if input_symbols.len() == 1 { "arg".to_string() } else { format!("args.{i}", i=i) };

                                        match input_symbols[i] {
                                            Symbol::Terminal(_) => write!(fmt, "self.lexeme(&{arg})", arg=arg)?,
                                            Symbol::Variable(_) => write!(fmt, "{arg}", arg=arg)?,
                                        }

                                        if i < input_symbols.len() - 1 {
                                            write!(fmt, ", ")?;
                                        }
                                    }
                                    writeln!(fmt, ")), {count})),", count=r.count-1)?;
                                }
                            };
                        }
                        if state.ttrans.len() < self.lexer.ttype_count {
                            writeln!(fmt, "token => return Err(ParseError::InvalidAction {{ state: {state}, ttype: token.map(|token| token.ttype) }}),", state=i)?;
                        }
                        fmt.unindent();
                    }
                    write!(fmt, "}}")?;

                    if state.has_shift_transitions {
                        writeln!(fmt, "?;")?;
                        if state.nttrans.is_empty() {
                            writeln!(fmt, "decrement(tuple)")?;
                        } else {
                            match arg {
                                Some((name, _)) => writeln!(fmt, "on_return(self, tuple, {argname})", argname=name)?,
                                None => writeln!(fmt, "on_return(self, tuple)")?,
                            }
                        }
                    } else {
                        writeln!(fmt)?;
                    }
                }

                fmt.unindent();
                writeln!(fmt, "}}")?;

                if i < self.states.len() - 1 {
                    writeln!(fmt)?;
                }
            }

            writeln!(fmt, "\nfn lexeme(&self, token: &Token) -> &[u8] {{")?;
            writeln!(fmt, "    &self.input.input[token.span.0..token.span.1]")?;
            writeln!(fmt, "}}")?;
        }
        fmt.unindent();
        
        writeln!(fmt, "}}")?;
        
        if uses_decrement {
            writeln!(fmt, "\nfn decrement((var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {{")?;
            writeln!(fmt, "    assert!(goto > 0);")?;
            writeln!(fmt, "    Ok((var, goto - 1))")?;
            writeln!(fmt, "}}")?;
        }
        
        Ok(fmt.build())
    }
}

fn arglist<W: Write>(fmt: &mut IndentWriter<W>, src: &rep::ParserState, dst: &rep::ParserState, arg: &str) -> Result<(), std::fmt::Error> {    
    let next_symbols = &dst.input_symbols;
    
    if next_symbols.len() > 1 {
        write!(fmt, "(")?;
    }

    let input_symbols = &src.input_symbols;
    let offset = input_symbols.len() - (next_symbols.len() - 1);
    
    for i in offset..input_symbols.len() {
        if src.input_symbols.len() == 1 {
            write!(fmt, "arg, ")?;
        } else {
            write!(fmt, "args.{i}, ", i=i)?;
        }
    }
    
    write!(fmt, "{}", arg)?;
    
    if next_symbols.len() > 1 {
        write!(fmt, ")")?;
    }
    
    Ok(())
}