#![allow(non_camel_case_types)]
#![allow(unused_comparisons)]
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(unused_mut)]
#![allow(clippy::match_same_arms)]
#![allow(clippy::needless_return)]
#![allow(clippy::unnecessary_wraps)]
#![allow(clippy::unit_arg)]

use std::str::from_utf8;

fn main() {
    println!("{:?}", parse("(10*3+1)+(3*5)+-1").unwrap());
}

type EProduct = i32;
type TProduct = i32;
type FProduct = i32;

// E -> E add T
fn p0(a: EProduct, _: &[u8], b: TProduct) -> EProduct {
    a + b
}

// E -> T
fn p1(x: TProduct) -> EProduct {
    x
}

// T -> T mul F
fn p2(a: TProduct, _: &[u8], b: FProduct) -> TProduct {
    a * b
}

// T -> F
fn p3(x: FProduct) -> TProduct {
    x
}

// F -> lparen E rparen
fn p4(_: &[u8], x: EProduct, _: &[u8]) -> FProduct {
    x
}

// F -> num
fn p5(bytes: &[u8]) -> FProduct {
    from_utf8(bytes).unwrap().parse().unwrap()
}

/* automatically generated by sylo */

pub fn scan<I: AsRef<[u8]> + ?Sized>(input: &I) -> Scan<'_> {
    Scan {
        input: input.as_ref(),
        index: 0,
    }
}

pub struct Scan<'a> {
    input: &'a [u8],
    index: usize,
}

#[derive(Debug)]
pub struct ScanError {
    pub pos: usize,
}

#[derive(Debug, Clone, Copy)]
pub enum TokenType {
    num,
    lparen,
    rparen,
    add,
    mul,
}

#[derive(Debug, Clone, Copy)]
pub struct Token {
    pub ttype: TokenType,
    pub span: (usize, usize),
}

impl<'a> Iterator for Scan<'a> {
    type Item = Result<Token, ScanError>;

    fn next(&mut self) -> Option<Self::Item> {
        self.begin()
    }
}

enum LastAcceptTType {
    Tok(TokenType),
    Error,
    Skip,
}

struct Context {
    start_index: usize,
    last_accept_ttype: LastAcceptTType,
    last_accept_index: usize,
}

impl Scan<'_> {
    fn begin(&mut self) -> Option<<Self as Iterator>::Item> {
        if self.index >= self.input.len() {
            return None;
        }

        let ctx = Context {
            start_index: self.index,
            last_accept_ttype: LastAcceptTType::Error,
            last_accept_index: 0,
        };

        self.s0(ctx)
    }

// *** LEXER TABLE START ***

    fn s0(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index < self.input.len() {
            let ch = self.input[self.index];
            if ch == 0x28 { self.index += 1; return self.s1(ctx); }
            if ch == 0x29 { self.index += 1; return self.s2(ctx); }
            if ch == 0x30 { self.index += 1; return self.s3(ctx); }
            if ch == 0x2d { self.index += 1; return self.s4(ctx); }
            if (0x31..=0x39).contains(&ch) { self.index += 1; return self.s5(ctx); }
            if ch == 0x2a { self.index += 1; return self.s6(ctx); }
            if ch == 0x2b { self.index += 1; return self.s7(ctx); }
        }
        self.sink(&ctx)
    }

    fn s1(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::lparen, span: (ctx.start_index, self.index) }))
    }

    fn s2(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::rparen, span: (ctx.start_index, self.index) }))
    }

    fn s3(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::num, span: (ctx.start_index, self.index) }))
    }

    fn s4(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index < self.input.len() {
            let ch = self.input[self.index];
            if (0x31..=0x39).contains(&ch) { self.index += 1; return self.s5(ctx); }
        }
        self.sink(&ctx)
    }

    fn s5(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        if self.index < self.input.len() {
            let ch = self.input[self.index];
            if (0x30..=0x39).contains(&ch) { self.index += 1; return self.s5(ctx); }
        }
        Some(Ok(Token { ttype: TokenType::num, span: (ctx.start_index, self.index) }))
    }

    fn s6(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::mul, span: (ctx.start_index, self.index) }))
    }

    fn s7(&mut self, mut ctx: Context) -> Option<<Self as Iterator>::Item> {
        Some(Ok(Token { ttype: TokenType::add, span: (ctx.start_index, self.index) }))
    }

// ***  LEXER TABLE END  ***

    fn sink(&mut self, ctx: &Context) -> Option<<Self as Iterator>::Item> {
        match ctx.last_accept_ttype {
            LastAcceptTType::Tok(ttype) => {
                self.index = ctx.last_accept_index;
                Some(Ok(Token { ttype, span: (ctx.start_index, ctx.last_accept_index) }))
            }
            LastAcceptTType::Error => {
                let pos = self.index;
                self.index = usize::MAX; // forces next iteration to return None
                Some(Err(ScanError { pos }))
            }
            LastAcceptTType::Skip => {
                self.index = ctx.last_accept_index;
                self.begin()
            }
        }
    }
}

pub fn parse<I: AsRef<[u8]> + ?Sized>(input: &I) -> Result<EProduct, ParseError> {
    let res = Parse { input: scan(input), next_token: None }.begin();
    match res? {
        Variable::E(product) => Ok(product),
        _ => unreachable!(),
    }
}

#[derive(Debug, Clone, Copy)]
pub enum Variable {
    E(EProduct),
    T(TProduct),
    F(FProduct),
}

pub struct Parse<'a> {
    input: Scan<'a>,
    next_token: Option<Token>,
}

#[derive(Debug)]
pub enum ParseError {
    InputError(ScanError),
    InvalidAction { state: usize, ttype: Option<TokenType> },
    InvalidGoto { state: usize },
}

impl Parse<'_> {
    fn begin(mut self) -> Result<Variable, ParseError> {
        self.update()?;
        Ok(self.s0()?.0)
    }

    fn update(&mut self) -> Result<(), ParseError> {
        self.next_token = self.input.next().transpose().map_err(|err| { ParseError::InputError(err) })?;
        Ok(())
    }

    fn s0(&mut self) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::E(v) => parse.s1(v),
                    Variable::T(v) => parse.s2(v),
                    Variable::F(v) => parse.s3(v),
                }?;
                on_return(parse, tuple)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::num, .. }) => { self.update()?; self.s5(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s4(t) }
            t => return Err(ParseError::InvalidAction { state: 0, ttype: t.map(|t| t.ttype) }),
        }?;
        on_return(self, tuple)
    }
    
    fn s1(&mut self, arg: EProduct) -> Result<(Variable, usize), ParseError> {
        let tuple = match self.next_token {
            None => return Ok((Variable::E(arg), 1)),
            Some(t @ Token { ttype: TokenType::add, .. }) => { self.update()?; self.s6((arg, t)) }
            t => return Err(ParseError::InvalidAction { state: 1, ttype: t.map(|t| t.ttype) }),
        }?;
        decrement(tuple)
    }
    
    fn s2(&mut self, arg: TProduct) -> Result<(Variable, usize), ParseError> {
        let tuple = match self.next_token {
            None => return Ok((Variable::E(p1(arg)), 0)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::E(p1(arg)), 0)),
            Some(t @ Token { ttype: TokenType::mul, .. }) => { self.update()?; self.s7((arg, t)) }
            t => return Err(ParseError::InvalidAction { state: 2, ttype: t.map(|t| t.ttype) }),
        }?;
        decrement(tuple)
    }
    
    fn s3(&mut self, arg: FProduct) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            None => return Ok((Variable::T(p3(arg)), 0)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::T(p3(arg)), 0)),
            Some(Token { ttype: TokenType::mul, .. }) => return Ok((Variable::T(p3(arg)), 0)),
            t => return Err(ParseError::InvalidAction { state: 3, ttype: t.map(|t| t.ttype) }),
        }
    }
    
    fn s4(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), arg: Token) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::E(v) => parse.s8((arg, v)),
                    Variable::T(v) => parse.s9(v),
                    Variable::F(v) => parse.s10(v),
                }?;
                on_return(parse, tuple, arg)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::num, .. }) => { self.update()?; self.s12(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s11(t) }
            t => return Err(ParseError::InvalidAction { state: 4, ttype: t.map(|t| t.ttype) }),
        }?;
        on_return(self, tuple, arg)
    }
    
    fn s5(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            None => return Ok((Variable::F(p5(self.lexeme(&arg))), 0)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::F(p5(self.lexeme(&arg))), 0)),
            Some(Token { ttype: TokenType::mul, .. }) => return Ok((Variable::F(p5(self.lexeme(&arg))), 0)),
            t => return Err(ParseError::InvalidAction { state: 5, ttype: t.map(|t| t.ttype) }),
        }
    }
    
    fn s6(&mut self, args: (EProduct, Token)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (EProduct, Token)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::T(v) => parse.s13((args.0, args.1, v)),
                    Variable::F(v) => parse.s3(v),
                    _ => return Err(ParseError::InvalidGoto { state: 6 }),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::num, .. }) => { self.update()?; self.s5(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s4(t) }
            t => return Err(ParseError::InvalidAction { state: 6, ttype: t.map(|t| t.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s7(&mut self, args: (TProduct, Token)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (TProduct, Token)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::F(v) => parse.s14((args.0, args.1, v)),
                    _ => return Err(ParseError::InvalidGoto { state: 7 }),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::num, .. }) => { self.update()?; self.s5(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s4(t) }
            t => return Err(ParseError::InvalidAction { state: 7, ttype: t.map(|t| t.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s8(&mut self, args: (Token, EProduct)) -> Result<(Variable, usize), ParseError> {
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::rparen, .. }) => { self.update()?; self.s16((args.0, args.1, t)) }
            Some(t @ Token { ttype: TokenType::add, .. }) => { self.update()?; self.s15((args.1, t)) }
            t => return Err(ParseError::InvalidAction { state: 8, ttype: t.map(|t| t.ttype) }),
        }?;
        decrement(tuple)
    }
    
    fn s9(&mut self, arg: TProduct) -> Result<(Variable, usize), ParseError> {
        let tuple = match self.next_token {
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::E(p1(arg)), 0)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::E(p1(arg)), 0)),
            Some(t @ Token { ttype: TokenType::mul, .. }) => { self.update()?; self.s17((arg, t)) }
            t => return Err(ParseError::InvalidAction { state: 9, ttype: t.map(|t| t.ttype) }),
        }?;
        decrement(tuple)
    }
    
    fn s10(&mut self, arg: FProduct) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::T(p3(arg)), 0)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::T(p3(arg)), 0)),
            Some(Token { ttype: TokenType::mul, .. }) => return Ok((Variable::T(p3(arg)), 0)),
            t => return Err(ParseError::InvalidAction { state: 10, ttype: t.map(|t| t.ttype) }),
        }
    }
    
    fn s11(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), arg: Token) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::E(v) => parse.s18((arg, v)),
                    Variable::T(v) => parse.s9(v),
                    Variable::F(v) => parse.s10(v),
                }?;
                on_return(parse, tuple, arg)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::num, .. }) => { self.update()?; self.s12(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s11(t) }
            t => return Err(ParseError::InvalidAction { state: 11, ttype: t.map(|t| t.ttype) }),
        }?;
        on_return(self, tuple, arg)
    }
    
    fn s12(&mut self, arg: Token) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::F(p5(self.lexeme(&arg))), 0)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::F(p5(self.lexeme(&arg))), 0)),
            Some(Token { ttype: TokenType::mul, .. }) => return Ok((Variable::F(p5(self.lexeme(&arg))), 0)),
            t => return Err(ParseError::InvalidAction { state: 12, ttype: t.map(|t| t.ttype) }),
        }
    }
    
    fn s13(&mut self, args: (EProduct, Token, TProduct)) -> Result<(Variable, usize), ParseError> {
        let tuple = match self.next_token {
            None => return Ok((Variable::E(p0(args.0, self.lexeme(&args.1), args.2)), 2)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::E(p0(args.0, self.lexeme(&args.1), args.2)), 2)),
            Some(t @ Token { ttype: TokenType::mul, .. }) => { self.update()?; self.s7((args.2, t)) }
            t => return Err(ParseError::InvalidAction { state: 13, ttype: t.map(|t| t.ttype) }),
        }?;
        decrement(tuple)
    }
    
    fn s14(&mut self, args: (TProduct, Token, FProduct)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            None => return Ok((Variable::T(p2(args.0, self.lexeme(&args.1), args.2)), 2)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::T(p2(args.0, self.lexeme(&args.1), args.2)), 2)),
            Some(Token { ttype: TokenType::mul, .. }) => return Ok((Variable::T(p2(args.0, self.lexeme(&args.1), args.2)), 2)),
            t => return Err(ParseError::InvalidAction { state: 14, ttype: t.map(|t| t.ttype) }),
        }
    }
    
    fn s15(&mut self, args: (EProduct, Token)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (EProduct, Token)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::T(v) => parse.s19((args.0, args.1, v)),
                    Variable::F(v) => parse.s10(v),
                    _ => return Err(ParseError::InvalidGoto { state: 15 }),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::num, .. }) => { self.update()?; self.s12(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s11(t) }
            t => return Err(ParseError::InvalidAction { state: 15, ttype: t.map(|t| t.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s16(&mut self, args: (Token, EProduct, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            None => return Ok((Variable::F(p4(self.lexeme(&args.0), args.1, self.lexeme(&args.2))), 2)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::F(p4(self.lexeme(&args.0), args.1, self.lexeme(&args.2))), 2)),
            Some(Token { ttype: TokenType::mul, .. }) => return Ok((Variable::F(p4(self.lexeme(&args.0), args.1, self.lexeme(&args.2))), 2)),
            t => return Err(ParseError::InvalidAction { state: 16, ttype: t.map(|t| t.ttype) }),
        }
    }
    
    fn s17(&mut self, args: (TProduct, Token)) -> Result<(Variable, usize), ParseError> {
        fn on_return(parse: &mut Parse, (var, goto): (Variable, usize), args: (TProduct, Token)) -> Result<(Variable, usize), ParseError> {
            if goto == 0 {
                let tuple = match var {
                    Variable::F(v) => parse.s20((args.0, args.1, v)),
                    _ => return Err(ParseError::InvalidGoto { state: 17 }),
                }?;
                on_return(parse, tuple, args)
            } else {
                Ok((var, goto - 1))
            }
        }
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::num, .. }) => { self.update()?; self.s12(t) }
            Some(t @ Token { ttype: TokenType::lparen, .. }) => { self.update()?; self.s11(t) }
            t => return Err(ParseError::InvalidAction { state: 17, ttype: t.map(|t| t.ttype) }),
        }?;
        on_return(self, tuple, args)
    }
    
    fn s18(&mut self, args: (Token, EProduct)) -> Result<(Variable, usize), ParseError> {
        let tuple = match self.next_token {
            Some(t @ Token { ttype: TokenType::rparen, .. }) => { self.update()?; self.s21((args.0, args.1, t)) }
            Some(t @ Token { ttype: TokenType::add, .. }) => { self.update()?; self.s15((args.1, t)) }
            t => return Err(ParseError::InvalidAction { state: 18, ttype: t.map(|t| t.ttype) }),
        }?;
        decrement(tuple)
    }
    
    fn s19(&mut self, args: (EProduct, Token, TProduct)) -> Result<(Variable, usize), ParseError> {
        let tuple = match self.next_token {
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::E(p0(args.0, self.lexeme(&args.1), args.2)), 2)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::E(p0(args.0, self.lexeme(&args.1), args.2)), 2)),
            Some(t @ Token { ttype: TokenType::mul, .. }) => { self.update()?; self.s17((args.2, t)) }
            t => return Err(ParseError::InvalidAction { state: 19, ttype: t.map(|t| t.ttype) }),
        }?;
        decrement(tuple)
    }
    
    fn s20(&mut self, args: (TProduct, Token, FProduct)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::T(p2(args.0, self.lexeme(&args.1), args.2)), 2)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::T(p2(args.0, self.lexeme(&args.1), args.2)), 2)),
            Some(Token { ttype: TokenType::mul, .. }) => return Ok((Variable::T(p2(args.0, self.lexeme(&args.1), args.2)), 2)),
            t => return Err(ParseError::InvalidAction { state: 20, ttype: t.map(|t| t.ttype) }),
        }
    }
    
    fn s21(&mut self, args: (Token, EProduct, Token)) -> Result<(Variable, usize), ParseError> {
        match self.next_token {
            Some(Token { ttype: TokenType::rparen, .. }) => return Ok((Variable::F(p4(self.lexeme(&args.0), args.1, self.lexeme(&args.2))), 2)),
            Some(Token { ttype: TokenType::add, .. }) => return Ok((Variable::F(p4(self.lexeme(&args.0), args.1, self.lexeme(&args.2))), 2)),
            Some(Token { ttype: TokenType::mul, .. }) => return Ok((Variable::F(p4(self.lexeme(&args.0), args.1, self.lexeme(&args.2))), 2)),
            t => return Err(ParseError::InvalidAction { state: 21, ttype: t.map(|t| t.ttype) }),
        }
    }
    
    fn lexeme(&self, token: &Token) -> &[u8] {
        &self.input.input[token.span.0..token.span.1]
    }
}

fn decrement((var, goto): (Variable, usize)) -> Result<(Variable, usize), ParseError> {
    assert!(goto > 0);
    Ok((var, goto - 1))
}
